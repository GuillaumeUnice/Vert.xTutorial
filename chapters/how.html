<section>
    <h3>How?</h3>
    <ul>
        <li>Process</li>
        <li>Thread</li><!-- Un Thread est un processus léger -->
        <!--
            Un processus peut contenir un ou plusieurs thread (applications dites multi-threadées) 
            s'exécutant en quasi-simultanéité ou simultanément sur les processeurs multi-coeurs. 
            A la différence des processus, les threads partage le même espace mémoire protégé, les mêmes ressources et le même espace mémoire.
        -->
        <li>Event Loop</li>
    </ul>
</section>
<section data-background-color="#666699">
    <img src="images/php.png" style="border: none;" alt="logo PHP" />
    <br>
    <ul>
        <li>Mono-Thread</li>
        <li>Synchronous</li>
    </ul>
    <p>
        => Solution configure a pool (launch a set of PHP's process) with load balancer
        <br>
        It's an Architrecture solution use by: Apache, Nginx, Jetty etc.
    </p>
    <!--
    Trop peu de processus risque d'attente de finition des opérations
    Trop de processus risque de trop de changement de contexte résultat perte de performances. Ou encore risque de saturation de la mémoire si utilisation de grosse lib PHP
    -->
</section>
<section data-background-color="#689F63">
    <img src="images/node.png" width="260px" style="border: none;" alt="logo Node.JS" />
    <br>
    <ul>
        <li>Mono-Thread</li>
        <li>Asynchronous</li>
    </ul>
    <p>
        => Solution based on callback, each function enters inside the loop (only one by one) then sends to the system
        <br>
        Then, computation ends the loop receives and trigs callback
        <br>
        It's an Applications Framework solution use by: Node.js, EventMachine(Ruby), Tornado(Python), etc.
        <!-- Ici c'est a nous de mettre en place le server d'ou son nom de soluton au niveau applicatif-->
    </p>
    <!-- 
        L'idée est d'avoir une boucle d'évènement monothread et de se reposer sur un système de callback
        Chaque fonction passe dans la boucle d'évènement une à une (attention une à une seulement) puis est envoyé directement
        au système donc traité à un niveau assez bas car il c'est mieux faire les choses que quiconque
        (gestion entrée/sortie, database, computation, network etc...)
        Une fois le traitement réalisé cela repasse dans notre boucle de monothread
        qui va appeler le trigger callback et lancé la calllback associé à la fonction
        Node, EventMachine(Ruby), Tornado or Twisted (Python) approche Applications framework		
    -->
</section>
<section>
    <img src="images/event-loop.jpg" width="450px" style="border: none;" alt="Event Loop schema" />
    <h3>Event Loop</h3>
	<ul>
        <li>Don't block event loop</li>
        <li>Long running calculations</li>
        <li>Blocking APIs (Java)</li>
        <li>Thread concurrency (synchronized,volatile, locking)</li>
    </ul>
</section>
<section data-background-color="#782B90">
    <img src="images/reactive.png" width="300px" style="border: none;" alt="logo Vertx reactive" />
    <h3>Hybrid Model</h3>
    <ul>
        <li>One JVM - One Vert.x instance</li>
        <li>One Vert.x instance - Thread number = Core number</li>
        <li>One Thread - One Event Loop</li>
        <li>Each Verticle assign One Thread</li>
        <!--Potentiellement un "event loop" peut etre assigné à plusieurs Verticle-->
    </ul>

<!--
    Finalement Vert.X prend le meilleur des deux mondes en faisant un entre deux et conservant ainsi cette approche au niveau pour nous 
	contrairement à du Go qui va nous obligé a pensé très bas niveau est avoir des architecture au cas par cas la on garde cette approche générique du probleme
    C'est finalement un modèle hybrid
    en faisant du fine-tune de l'affinage en fonction du nombre de coeur de la machine et en conservant l'approche Asynchrone
    les Worker Verticle peuvent finalement eux opérer des opérations bloquante comme traditionneleement dans l'écosystème synchrone Java ou PHP
-->
<!-- basé sur le pattern multi-reactor -->
</section>
	